/*
* 1. Написать функцию возведения числа в степень. */

// степень числа x в степени y равна x в степени y - 1 умноженное на X, т.е x**y = x**(y-1) * x
// Вариант 1
function exp(num, rate = 2) {
	// крайний случай, если rate равно нулю, возвращаем 1
	if (rate === 0) return 1;
	// иначе функция вызывает саму себя со значением --rate
	else return exp(num, --rate) * num;
	// после того как цепочка вызовов дойдет до нуля, вернется единица и при возврате в вызывающую функцию будет умножаться на num
}

// Вариант 2
const exp2 = (num, rate = 2) => rate === 0 ? 1 : exp2(num, --rate) * num;

/*
* 2. Написать функцию поиска наибольшего общего делителя. */

/* Алгоритм Евклида
	Если при делении двух чисел остаток равен нулю, делитель является НОД.
	Иначе, берем остаток от деления и пытаемся разделить делитель на остаток 
	т.е если x не делится на y, делим y на x%y */

// Вариант 1
function div(x, y) {
	// если от вызывающей функции в качестве второго параметра получим x % y и он будет равен нулю, значит первый параметр НОД
	if (y === 0) return x;
	// в вызываемую функцию передаем первый аргумент: делимое, второй: остаток от деления
	else return div(y, x % y);
}

// Вариант 2:
// благодаря неявному возврату стрелочной функции, можно не писать return,
// используя тернарный оператор, можно записать короче
const div2 = (x, y) => y === 0 ? x : div2(y, x % y);


/*
* 3. Написать функцию для поиска максимальной цифры в числе. */
/* будем делить переданное число на 10 и передавать в следующую функцию maxDigit в уменьшенном виде
	до тех пор пока число не станет <=1.
	Затем вызовы прекращаются и вы выходе сравниваем возвращаемые значения с сохраненным в кажндой функции числом a.
*/
function maxDigit(num) {
	if (num > 1) {
		// созраняем значение последней цифры
		let a = num % 10;
		// уменьшаем число на одну цифру и передаем следующей функции
		let b = maxDigit(Math.trunc(num / 10));
		// при возврате сравниваем оба числа и возвращаем большее значнние
		return a > b ? a : b;
	}
	// крайний случай, если num <=1, прекращаем вызовы и возвращаем 0
	else
		return 0;
}

/*
* 4. Написать функцию, которая определяет простое ли переданное число. */
// что бы определить простоту числа, будем делить его на числа от num - 1 до 2

// в качестве аргумента по умолчанию, передадим функции div = num - 1 и будем использовать как переменную
function primeNum(num, div = num - 1) {
	// т.к. 1 не простое и не сложное, проверим его отдельно
	if (num === 1) return 'one'
	// крайний случай, если дошли до 1 и не нашли делитель, число простое
	if (div === 1) return 'prime';
	// если встретился хоть один делитель, число не простое
	if (num % div === 0) return 'not-prime';
	// если ничего не сработало, вызываем слудующую функцию и уменьшаем div на 1
	else return primeNum(num, --div);
}

/*
* 5. Написать функцию для вывода всех множителей переданного числа в возрастающем порядке. */
/* самый простой алгоритм факторизации, это перебор делителей, делим число n последовательно на 
	натуральные числа от 2 до корень из n.
 */
// в качастве аргументов по умолчании передадим пустой массив для хранения значений и переменную div для храниения делителя
function factoriz(num, array = [], div = 2) {
	// если div больше корня из num, значил либо это последний делитель, либо единственный
	if (div > Math.sqrt(num)) {
		// добавляем num в массив и возвращаем результат
		array.push(num);
		return array;
		// если num делится на div 
	} else if (num % div == 0) {
		// добавляем div в массив
		array.push(div);
		// передаем следующей функции результат деления и то же число, что бы еще раз проверить делимость на него
		factoriz(num / div, array, div);
		// если num не делится на div
	} else factoriz(num, array, ++div); // num передаем неизменным, а div увеличиваем на 1
	// заменяем дефолтные разделители на *
	return array.join(" * ");
}

/*
* 6. Написать функцию, которая возвращает число Фибоначчи по переданному порядковому номеру.  */
// если каждое число равно сумме двух предыдущих чисел, значит fib(n) = fib(n-1) + fib(n-2)
// Вариант 1
function fib(n) {
	// крайний случай, если n достигнет 1, завершаем работу и возвращаем n
	if (n <= 1) return n;
	// иначе вызываем функции числа фибоначчи двух предыдущих и складываем
	else return fib(n - 1) + fib(n - 2);
}

//Вариант 2: через стрелочную функцию
const fib2 = n => n <= 1 ? n : fib(n - 1) + fib(n - 2);